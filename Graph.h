

#ifndef GRAPH_H
#define GRAPH_H

#include <vector>
#include <array>
#include <unordered_map>
#include <unordered_set>
#include <cassert>
#include <algorithm>

template <typename V, typename E>
struct edge;

/** \brief A vertex of a graph.
*	\tparam V is the type of vertex data.
*	\tparam E is the type of edge data.
*
*	This struct is a container of edges and data specific to the vertex.
*	Although the vertex's edges are publicly accessible, they are only
*	to be removed/added through the containing graph's methods.
*/
template <typename V, typename E>
struct vertex
{
	/** \brief The Vertex constructor.
	*	\param data is the vertex's data.
	*/
	vertex(const V& data)
	: data(data)
	{
		;
	}

	/** \brief The edges connected to this vertex.
	*/
	std::vector<edge<V, E>*> edges;
	/** \brief The data held by this vertex.
	*/
	V data;
};

/** \brief An edge of a graph.
*	\tparam V is the type of vertex data.
*	\tparam E is the type of edge data.
*
*	This struct is a container of vertices and data specific to the edge.
*	Although the edge's vertices are publicly accessible and not const,
*	this is only to allow for altering vertex data; do not change the
*	addresses of the pointers.
*/
template <typename V, typename E>
struct edge
{
	/** \brief The Edge constructor.
	*	\param vertices are the two vertices which this edge connects.
	*	\param data is the edge's data
	*/
	edge(const std::array<vertex<V, E>*, 2>& vertices, const E& data)
	: vertices(vertices), data(data)
	{

	}

	/** \brief The vertices connected by this edge.
	*/
	std::array<vertex<V, E>*, 2> vertices;
	/** \brief The data held by this vertex.
	*/
	E data;
};

/** \brief A mathematical graph object.
*	\tparam K is the type of key used for accesing the vertices.
*	\tparam H is the type of hash generated by for K.
*	\tparam V is the type of vertex data.
*	\tparam E is the type of edge data.
*
*	The name dynamic_sparse_graph was chosen to indicate the features
*	and optimal usage for this object; the graph is dynamic because it
*	add and remove vertices and edges, and the graph is sparse because
*	it implements an adjaceny list and as such is best used for
*	representing sparse graphs.\n
*	This object is built upon an unordered_map of vertices.\n
*	This class is not responsible for managing any heap memory which its
*	vertices and edges might point to.
*/
template <typename K, typename H, typename V, typename E>
class dynamic_sparse_graph
{
	/** \brief The output-bitshift operator.
	*	\param os is the stream to which the graph is output.
	*	\param graph is the graph which is output.
	*	\return the stream after outputting the graph to it.
	*
	*	This function is useful for debugging; it outputs the addresses of
	*	the graph, its vertices, and the vertices' edges.
	*/
	friend std::ostream& operator<<(std::ostream& os, const dynamic_sparse_graph& graph)
	{
		os << "Graph " << &graph << ":\n";
		for (auto vertex : graph.vertices)
		{
			os << "  Vertex " << vertex.second << ":\n";
			for (auto edge : vertex.second->edges)
			{
				os << "    Edge " << edge << ": " << edge->vertices.at(0) << " to " << edge->vertices.at(1) << "\n";
			}
		}

		return os;
	}

	/** \brief Swaps two dynamic_sparse_graph objects.
	*	\param lhs is the first graph.
	*	\param rhs is the second graph.
	*
	*	This function is implemented for use with the copy-swap idiom.
	*	In particular, both graphs are left in an assignable/destructable
	*	state.
	*/
	friend void swap(dynamic_sparse_graph<K, H, V, E>& lhs, dynamic_sparse_graph<K, H, V, E>& rhs)
	{
		size_t temp = lhs.vertex_count;
		lhs.vertex_count = rhs.vertex_count;
		rhs.vertex_count = temp;

		lhs.vertices.swap(rhs.vertices);
	}

public:
	/** \brief The default constructor.
	*
	*	vertex_count is initialized to 0.
	*/
	dynamic_sparse_graph()
	: vertex_count(0)
	{
		;
	}
	/** \brief The copy constructor.
	*	\param rhs is the graph to copy.
	*
	*	A first loop iterates through the rhs graph to copy its vertices.
	*	A second loop iterates through the rhs graph to copy its edges.\n
	*	vertex_count is initialized to 0 prior to these loops, however.
	*/
	dynamic_sparse_graph(const dynamic_sparse_graph<K,H,V,E>& rhs)
	: vertex_count(0)
	{
		for (auto rhs_vertex : rhs.vertices)
			this->add_vertex(rhs_vertex.first, rhs_vertex.second->data);

		std::unordered_set<edge<V, E>*> rhs_edges;

		for (auto rhs_vertex : rhs.vertices)
		{
			for (auto rhs_edge : rhs_vertex.second->edges)
			{
				auto rhs_edges_it = rhs_edges.find(rhs_edge);
				if (rhs_edges_it == rhs_edges.end())
				{
					rhs_edges.insert(rhs_edge);

					if (rhs_edge->vertices.at(0) == rhs_vertex.second)
						this->add_edge(rhs_vertex.first, rhs.get_key(*rhs_edge->vertices.at(1)), rhs_edge->data);
					else
						this->add_edge(rhs_vertex.first, rhs.get_key(*rhs_edge->vertices.at(0)), rhs_edge->data);
				}
				else
					rhs_edges.erase(rhs_edge);
			}
		}

	}
	/** \brief The move constructor.
	*	\param rhs is the graph to copy.
	*
	*	The swap function is called. As a result, the code is more
	*	elegant but it may run slower.
	*/
	dynamic_sparse_graph(dynamic_sparse_graph<K, H, V, E>&& rhs)
	: dynamic_sparse_graph()
	{
		swap(*this, rhs);
	}

	/** \brief The assignment operator.
	*	\param rhs is the graph to be assigned.
	*	\return this graph post-assignment.
	*	
	*	This function is implemented according to the copy-swap idiom.
	*/
	dynamic_sparse_graph& operator=(dynamic_sparse_graph<K,H,V,E> rhs)
	{
		swap(*this, rhs);

		return *this;
	}
	/**	\brief The move assignment operator.
	*	\param rhs is the graph to be assigned.
	*	\return this graph post-assignment.
	*
	*	The swap function is called. As a result, the code is more
	*	elegant but it may run slower. This function is identical to
	*	the ordinary assignment operator.
	*/
	dynamic_sparse_graph& operator=(dynamic_sparse_graph<K, H, V, E>&& rhs)
	{
		swap(*this, rhs);

		return *this;
	}

	/**	\brief The destructor.
	*	
	*	While vertices exist, remove_vertex is called on the last one.
	*/
	~dynamic_sparse_graph()
	{
		while (vertex_count > 0)
			remove_vertex((--vertices.end())->first);
	}

	/** \brief Reserves memory for the underlying unordered_map.
	*	\param expected_vertex_count is the expected number of vertices
	*		   that the graph is expected to contain.
	*/
	void reserve(size_t expected_vertex_count)
	{
		vertices.reserve(expected_vertex_count);
	}

	/** \brief Adds a vertex to the graph.
	*	\param key is the key at which to store the vertex.
	*	\param vertex_data is the data held by the vertex.
	*
	*	This function does not check for pre-existing vertices.
	*	Memory is allocated.
	*/
	void add_vertex(const K& key, const V& vertex_data)
	{
		std::pair<K, vertex<V, E>*> new_pair(key, new vertex<V,E>(vertex_data));
		
		vertices.insert(new_pair);
		++vertex_count;
	}
	/** \brief Adds an edge to the graph.
	*	\param key_1 is the key corresponding to the first vertex.
	*	\param key_2 is the key corresponding to the second vertex.
	*	\param edge_data is the data held by the edge.
	*
	*	This function asserts that the key arguments are not equal and
	*	checks that vertices do indeed exist at the input keys. Memory
	*	is allocated.
	*/
	void add_edge(const K& key_1, const K& key_2, const E& edge_data)
	{
		assert(key_1 != key_2);

		vertex<V, E>* vertex_1 = vertices.at(key_1);
		vertex<V, E>* vertex_2 = vertices.at(key_2);

		std::array<vertex<V, E>*, 2> new_edge_vertices = { vertex_1, vertex_2 };

		edge<V, E>* new_edge = new edge<V, E>(new_edge_vertices, edge_data);

		vertex_1->edges.push_back(new_edge);
		vertex_2->edges.push_back(new_edge);
	}

	/** \brief Retrieve the vertex at the given input.
	*	\param key is the key corresponding to desired vertex.
	*	\return the vertex at the given input.
	*
	*	This function checks for the existence of the vertex.
	*/
	vertex<V, E>& get_vertex(const K& key) const
	{
		return *vertices.at(key);
	}
	/** \brief Retrieve the edge connecting the vertices at the given input.
	*	\param key_1 is the key corresponding to the first vertex.
	*	\param key_2 is the key corresponding to the second vertex.
	*	\return the edge connecting the vertices at the given input.
	*
	*	This function asserts that the keys are not equal
	*	and that the edge exists, and checks that vertices
	*	do indeed exist at the input keys.
	*/
	edge<V, E>& get_edge(const K& key_1, const K& key_2) const
	{
		assert(key_1 != key_2);

		vertex<V, E>* vertex_1 = vertices.at(key_1);
		vertex<V, E>* vertex_2 = vertices.at(key_2);

		auto edge_it = vertex_1->edges.begin();

		while (edge_it != vertex_1->edges.end()
			&& (*edge_it)->vertices.at(0) != vertex_2
			&& (*edge_it)->vertices.at(1) != vertex_2)
		{
			++edge_it;
		}

		assert(edge_it != vertex_1->edges.end());

		return *(*edge_it);
	}
	/** \brief Retrieve the key of the input vertex.
	*	\param vertex is the vertex of the desired key.
	*	\return the key of the input vertex.
	*
	*	This function asserts that the vertex exists in the graph.
	*/
	K get_key(const vertex<V, E>& vertex) const
	{
		auto vertex_it = vertices.begin();

		while (vertex_it != vertices.end()
			&& vertex_it->second != &vertex)
		{
			++vertex_it;
		}

		assert(vertex_it != vertices.end());

		return vertex_it->first;
	}
	/** \brief Retrieve the number of vertices in the graph.
	*	\return the number of vertices in the graph.
	*/
	size_t get_size() const
	{
		return vertex_count;
	}

	/** \brief Remove the vertex at the given input.
	*	\param key is the key corresponding to the desired vertex.
	*
	*	This function checks for the existence of the vertex. The
	*	edges of the vertex are also removed. Memory is deleted.
	*/
	void remove_vertex(const K& key)
	{
		vertex<V, E>* old_vertex = vertices.at(key);
		vertex<V, E>* connected_vertex;

		edge<V, E>* old_edge;

		while (old_vertex->edges.size() > 0)
		{
			old_edge = *(--old_vertex->edges.end());

			if (old_vertex == old_edge->vertices.at(0))
				connected_vertex = old_edge->vertices.at(1);
			else
				connected_vertex = old_edge->vertices.at(0);

			old_vertex->edges.pop_back();

			auto old_edge_it = std::find(connected_vertex->edges.begin(), connected_vertex->edges.end(), old_edge);
			*old_edge_it = *(--connected_vertex->edges.end());
			connected_vertex->edges.pop_back();

			delete old_edge;
		}

		delete old_vertex;
		vertices.erase(key);
		--vertex_count;
	}
	/** \brief Remove the edge conntecting the vertices at the given input.
	*	\param key_1 is the key corresponding to the origin vertex.
	*	\param key_2 is the key corresponding to the destination vertex.
	*
	*	This function asserts that the keys are not equal
	*	and that the edge exists, and checks that vertices
	*	do indeed exist at the input keys. Memory is deleted.
	*/
	void remove_edge(const K& key_1, const K& key_2)
	{
		assert(key_1 != key_2);

		vertex<V, E>* vertex_1 = vertices.at(key_1);
		vertex<V, E>* vertex_2 = vertices.at(key_2);

		auto edge_it = vertex_1->edges.begin();

		while (edge_it != vertex_1->edges.end()
			&& (*edge_it)->vertices.at(0) != vertex_2
			&& (*edge_it)->vertices.at(1) != vertex_2)
		{
			++edge_it;
		}

		assert(edge_it != vertex_1->edges.end());

		edge<V, E>* old_edge = *edge_it;

		*edge_it = *(--vertex_1->edges.end());
		vertex_1->edges.pop_back();

		auto old_edge_it = std::find(vertex_2->edges.begin(), vertex_2->edges.end(), old_edge);
		*old_edge_it = *(--vertex_2->edges.end());
		vertex_2->edges.pop_back();

		delete old_edge;
	}

private:
	/** \brief This is the number of vertices contained by the graph.
	*/
	size_t vertex_count;
	/** \brief This is the container of the graph's vertices.
	*/
	std::unordered_map<K, vertex<V, E>*, H> vertices;

};

#endif GRAPH_H