<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Dynamic Sparse Graph: dynamic_sparse_graph&lt; K, H, V, E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Dynamic Sparse Graph
   </div>
   <div id="projectbrief">Implementation of a dynamic sparse graph.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdynamic__sparse__graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dynamic_sparse_graph&lt; K, H, V, E &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A mathematical graph object.  
 <a href="classdynamic__sparse__graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8655f2ac67ccc28c88585b0274d83dae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a8655f2ac67ccc28c88585b0274d83dae">dynamic_sparse_graph</a> ()</td></tr>
<tr class="memdesc:a8655f2ac67ccc28c88585b0274d83dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor.  <a href="#a8655f2ac67ccc28c88585b0274d83dae">More...</a><br /></td></tr>
<tr class="separator:a8655f2ac67ccc28c88585b0274d83dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0948114b7972032cff225a02c542e800"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a0948114b7972032cff225a02c542e800">dynamic_sparse_graph</a> (const <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0948114b7972032cff225a02c542e800"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor.  <a href="#a0948114b7972032cff225a02c542e800">More...</a><br /></td></tr>
<tr class="separator:a0948114b7972032cff225a02c542e800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3b2af233063af6aaf248c321a38edb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a2c3b2af233063af6aaf248c321a38edb">dynamic_sparse_graph</a> (<a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a2c3b2af233063af6aaf248c321a38edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move constructor.  <a href="#a2c3b2af233063af6aaf248c321a38edb">More...</a><br /></td></tr>
<tr class="separator:a2c3b2af233063af6aaf248c321a38edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7f3f46c94242dd69a9d898a87a0d28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a6c7f3f46c94242dd69a9d898a87a0d28">operator=</a> (<a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt; rhs)</td></tr>
<tr class="memdesc:a6c7f3f46c94242dd69a9d898a87a0d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">The assignment operator.  <a href="#a6c7f3f46c94242dd69a9d898a87a0d28">More...</a><br /></td></tr>
<tr class="separator:a6c7f3f46c94242dd69a9d898a87a0d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb2ab8ecfd4c69ea31ff414da9ba953"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a4cb2ab8ecfd4c69ea31ff414da9ba953">operator=</a> (<a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a4cb2ab8ecfd4c69ea31ff414da9ba953"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move assignment operator.  <a href="#a4cb2ab8ecfd4c69ea31ff414da9ba953">More...</a><br /></td></tr>
<tr class="separator:a4cb2ab8ecfd4c69ea31ff414da9ba953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad550e140d53117698201ca22574ec1a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#ad550e140d53117698201ca22574ec1a6">~dynamic_sparse_graph</a> ()</td></tr>
<tr class="memdesc:ad550e140d53117698201ca22574ec1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor.  <a href="#ad550e140d53117698201ca22574ec1a6">More...</a><br /></td></tr>
<tr class="separator:ad550e140d53117698201ca22574ec1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bc595af88b2172862987db75c4f830"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a84bc595af88b2172862987db75c4f830">reserve</a> (size_t expected_vertex_count)</td></tr>
<tr class="memdesc:a84bc595af88b2172862987db75c4f830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves memory for the underlying unordered_map.  <a href="#a84bc595af88b2172862987db75c4f830">More...</a><br /></td></tr>
<tr class="separator:a84bc595af88b2172862987db75c4f830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e079c373c2365513912b2f1db665fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a1e079c373c2365513912b2f1db665fdd">add_vertex</a> (const K &amp;key, const V &amp;vertex_data)</td></tr>
<tr class="memdesc:a1e079c373c2365513912b2f1db665fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex to the graph.  <a href="#a1e079c373c2365513912b2f1db665fdd">More...</a><br /></td></tr>
<tr class="separator:a1e079c373c2365513912b2f1db665fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb5cc4431b2b76d01c3a853e04c610a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a9eb5cc4431b2b76d01c3a853e04c610a">add_edge</a> (const K &amp;key_1, const K &amp;key_2, const E &amp;edge_data)</td></tr>
<tr class="memdesc:a9eb5cc4431b2b76d01c3a853e04c610a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge to the graph.  <a href="#a9eb5cc4431b2b76d01c3a853e04c610a">More...</a><br /></td></tr>
<tr class="separator:a9eb5cc4431b2b76d01c3a853e04c610a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efd32f8a74d04dbc6580176ac9c5840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvertex.html">vertex</a>&lt; V, E &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a9efd32f8a74d04dbc6580176ac9c5840">get_vertex</a> (const K &amp;key) const </td></tr>
<tr class="memdesc:a9efd32f8a74d04dbc6580176ac9c5840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the vertex at the given input.  <a href="#a9efd32f8a74d04dbc6580176ac9c5840">More...</a><br /></td></tr>
<tr class="separator:a9efd32f8a74d04dbc6580176ac9c5840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25a322a5ece881ea7ca71fb4b6d3dd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structedge.html">edge</a>&lt; V, E &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#ab25a322a5ece881ea7ca71fb4b6d3dd2">get_edge</a> (const K &amp;key_1, const K &amp;key_2) const </td></tr>
<tr class="memdesc:ab25a322a5ece881ea7ca71fb4b6d3dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the edge connecting the vertices at the given input.  <a href="#ab25a322a5ece881ea7ca71fb4b6d3dd2">More...</a><br /></td></tr>
<tr class="separator:ab25a322a5ece881ea7ca71fb4b6d3dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99591a4ba35e3ab63df0db306fa70cfb"><td class="memItemLeft" align="right" valign="top">K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a99591a4ba35e3ab63df0db306fa70cfb">get_key</a> (const <a class="el" href="structvertex.html">vertex</a>&lt; V, E &gt; &amp;<a class="el" href="structvertex.html">vertex</a>) const </td></tr>
<tr class="memdesc:a99591a4ba35e3ab63df0db306fa70cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the key of the input vertex.  <a href="#a99591a4ba35e3ab63df0db306fa70cfb">More...</a><br /></td></tr>
<tr class="separator:a99591a4ba35e3ab63df0db306fa70cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0253cc8b89538ee083af8ceb375dc26e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a0253cc8b89538ee083af8ceb375dc26e">get_size</a> () const </td></tr>
<tr class="memdesc:a0253cc8b89538ee083af8ceb375dc26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of vertices in the graph.  <a href="#a0253cc8b89538ee083af8ceb375dc26e">More...</a><br /></td></tr>
<tr class="separator:a0253cc8b89538ee083af8ceb375dc26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e7f038016167d47560f7e8b1d53ec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a05e7f038016167d47560f7e8b1d53ec3">remove_vertex</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a05e7f038016167d47560f7e8b1d53ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the vertex at the given input.  <a href="#a05e7f038016167d47560f7e8b1d53ec3">More...</a><br /></td></tr>
<tr class="separator:a05e7f038016167d47560f7e8b1d53ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e377f2d740acef43e1528041b94e52d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a5e377f2d740acef43e1528041b94e52d">remove_edge</a> (const K &amp;key_1, const K &amp;key_2)</td></tr>
<tr class="memdesc:a5e377f2d740acef43e1528041b94e52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the edge conntecting the vertices at the given input.  <a href="#a5e377f2d740acef43e1528041b94e52d">More...</a><br /></td></tr>
<tr class="separator:a5e377f2d740acef43e1528041b94e52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a674ca4493524c0cfb23ded95a9e0b554"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#a674ca4493524c0cfb23ded95a9e0b554">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a674ca4493524c0cfb23ded95a9e0b554"><td class="mdescLeft">&#160;</td><td class="mdescRight">The output-bitshift operator.  <a href="#a674ca4493524c0cfb23ded95a9e0b554">More...</a><br /></td></tr>
<tr class="separator:a674ca4493524c0cfb23ded95a9e0b554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8b9cef2cfb6649bf4d19e57b222388"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamic__sparse__graph.html#adc8b9cef2cfb6649bf4d19e57b222388">swap</a> (<a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt; &amp;lhs, <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt; &amp;rhs)</td></tr>
<tr class="memdesc:adc8b9cef2cfb6649bf4d19e57b222388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two <a class="el" href="classdynamic__sparse__graph.html" title="A mathematical graph object. ">dynamic_sparse_graph</a> objects.  <a href="#adc8b9cef2cfb6649bf4d19e57b222388">More...</a><br /></td></tr>
<tr class="separator:adc8b9cef2cfb6649bf4d19e57b222388"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename K, typename H, typename V, typename E&gt;<br />
class dynamic_sparse_graph&lt; K, H, V, E &gt;</h3>

<p>A mathematical graph object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>is the type of key used for accesing the vertices. </td></tr>
    <tr><td class="paramname">H</td><td>is the type of hash generated by for K. </td></tr>
    <tr><td class="paramname">V</td><td>is the type of vertex data. </td></tr>
    <tr><td class="paramname">E</td><td>is the type of edge data.</td></tr>
  </table>
  </dd>
</dl>
<p>The name <a class="el" href="classdynamic__sparse__graph.html" title="A mathematical graph object. ">dynamic_sparse_graph</a> was chosen to indicate the features and optimal usage for this object; the graph is dynamic because it add and remove vertices and edges, and the graph is sparse because it implements an adjaceny list and as such is best used for representing sparse graphs.<br />
This object is built upon an unordered_map of vertices.<br />
This class is not responsible for managing any heap memory which its vertices and edges might point to. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8655f2ac67ccc28c88585b0274d83dae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::<a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default constructor. </p>
<p>vertex_count is initialized to 0. </p>

</div>
</div>
<a class="anchor" id="a0948114b7972032cff225a02c542e800"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::<a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>is the graph to copy.</td></tr>
  </table>
  </dd>
</dl>
<p>A first loop iterates through the rhs graph to copy its vertices. A second loop iterates through the rhs graph to copy its edges.<br />
vertex_count is initialized to 0 prior to these loops, however. </p>

</div>
</div>
<a class="anchor" id="a2c3b2af233063af6aaf248c321a38edb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::<a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>is the graph to copy.</td></tr>
  </table>
  </dd>
</dl>
<p>The swap function is called. As a result, the code is more elegant but it may run slower. </p>

</div>
</div>
<a class="anchor" id="ad550e140d53117698201ca22574ec1a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::~<a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor. </p>
<p>While vertices exist, remove_vertex is called on the last one. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9eb5cc4431b2b76d01c3a853e04c610a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::add_edge </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>edge_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an edge to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_1</td><td>is the key corresponding to the first vertex. </td></tr>
    <tr><td class="paramname">key_2</td><td>is the key corresponding to the second vertex. </td></tr>
    <tr><td class="paramname">edge_data</td><td>is the data held by the edge.</td></tr>
  </table>
  </dd>
</dl>
<p>This function asserts that the key arguments are not equal and checks that vertices do indeed exist at the input keys. Memory is allocated. </p>

</div>
</div>
<a class="anchor" id="a1e079c373c2365513912b2f1db665fdd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::add_vertex </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>vertex_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a vertex to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the key at which to store the vertex. </td></tr>
    <tr><td class="paramname">vertex_data</td><td>is the data held by the vertex.</td></tr>
  </table>
  </dd>
</dl>
<p>This function does not check for pre-existing vertices. Memory is allocated. </p>

</div>
</div>
<a class="anchor" id="ab25a322a5ece881ea7ca71fb4b6d3dd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structedge.html">edge</a>&lt;V, E&gt;&amp; <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::get_edge </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the edge connecting the vertices at the given input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_1</td><td>is the key corresponding to the first vertex. </td></tr>
    <tr><td class="paramname">key_2</td><td>is the key corresponding to the second vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the edge connecting the vertices at the given input.</dd></dl>
<p>This function asserts that the keys are not equal and that the edge exists, and checks that vertices do indeed exist at the input keys. </p>

</div>
</div>
<a class="anchor" id="a99591a4ba35e3ab63df0db306fa70cfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::get_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvertex.html">vertex</a>&lt; V, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the key of the input vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>is the vertex of the desired key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the key of the input vertex.</dd></dl>
<p>This function asserts that the vertex exists in the graph. </p>

</div>
</div>
<a class="anchor" id="a0253cc8b89538ee083af8ceb375dc26e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::get_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the number of vertices in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of vertices in the graph. </dd></dl>

</div>
</div>
<a class="anchor" id="a9efd32f8a74d04dbc6580176ac9c5840"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvertex.html">vertex</a>&lt;V, E&gt;&amp; <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::get_vertex </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the vertex at the given input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the key corresponding to desired vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex at the given input.</dd></dl>
<p>This function checks for the existence of the vertex. </p>

</div>
</div>
<a class="anchor" id="a6c7f3f46c94242dd69a9d898a87a0d28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&amp; <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>is the graph to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this graph post-assignment.</dd></dl>
<p>This function is implemented according to the copy-swap idiom. </p>

</div>
</div>
<a class="anchor" id="a4cb2ab8ecfd4c69ea31ff414da9ba953"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&amp; <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>is the graph to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this graph post-assignment.</dd></dl>
<p>The swap function is called. As a result, the code is more elegant but it may run slower. This function is identical to the ordinary assignment operator. </p>

</div>
</div>
<a class="anchor" id="a5e377f2d740acef43e1528041b94e52d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::remove_edge </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the edge conntecting the vertices at the given input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_1</td><td>is the key corresponding to the origin vertex. </td></tr>
    <tr><td class="paramname">key_2</td><td>is the key corresponding to the destination vertex.</td></tr>
  </table>
  </dd>
</dl>
<p>This function asserts that the keys are not equal and that the edge exists, and checks that vertices do indeed exist at the input keys. Memory is deleted. </p>

</div>
</div>
<a class="anchor" id="a05e7f038016167d47560f7e8b1d53ec3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::remove_vertex </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the vertex at the given input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the key corresponding to the desired vertex.</td></tr>
  </table>
  </dd>
</dl>
<p>This function checks for the existence of the vertex. The edges of the vertex are also removed. Memory is deleted. </p>

</div>
</div>
<a class="anchor" id="a84bc595af88b2172862987db75c4f830"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expected_vertex_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves memory for the underlying unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expected_vertex_count</td><td>is the expected number of vertices that the graph is expected to contain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a674ca4493524c0cfb23ded95a9e0b554"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The output-bitshift operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>is the stream to which the graph is output. </td></tr>
    <tr><td class="paramname">graph</td><td>is the graph which is output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the stream after outputting the graph to it.</dd></dl>
<p>This function is useful for debugging; it outputs the addresses of the graph, its vertices, and the vertices' edges. </p>

</div>
</div>
<a class="anchor" id="adc8b9cef2cfb6649bf4d19e57b222388"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename H, typename V, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdynamic__sparse__graph.html">dynamic_sparse_graph</a>&lt; K, H, V, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two <a class="el" href="classdynamic__sparse__graph.html" title="A mathematical graph object. ">dynamic_sparse_graph</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>is the first graph. </td></tr>
    <tr><td class="paramname">rhs</td><td>is the second graph.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is implemented for use with the copy-swap idiom. In particular, both graphs are left in an assignable/destructable state. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Brenden/Documents/Visual Studio 2013/Projects/Miscellaneous/Graph/Graph/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 16 2015 05:00:21 for Dynamic Sparse Graph by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
